import{_ as a,C as n,o as l,c as i,aj as r,E as o}from"./chunks/framework.C0O9U8MM.js";const u=JSON.parse('{"title":"客户端（代理软件）","description":"","frontmatter":{},"headers":[],"relativePath":"墙外指南/软件下载/proxy-client/client.md","filePath":"墙外指南/软件下载/proxy-client/client.md","lastUpdated":1769180621000}'),s={name:"墙外指南/软件下载/proxy-client/client.md"};function d(g,t,h,c,f,x){const e=n("sidebar");return l(),i("div",null,[t[0]||(t[0]=r('<h1 id="客户端-代理软件" tabindex="-1">客户端（代理软件） <a class="header-anchor" href="#客户端-代理软件" aria-label="Permalink to &quot;客户端（代理软件）&quot;">​</a></h1><div class="custom-block info"><p class="custom-block-title">提示</p><p>若下载速度过慢或无法下载，请阅读《<a href="/教程/加速GitHub下载.html">加速 GitHub 下载</a>》一文。</p></div><h2 id="免客户端翻墙" tabindex="-1">免客户端翻墙 <a class="header-anchor" href="#免客户端翻墙" aria-label="Permalink to &quot;免客户端翻墙&quot;">​</a></h2><ul><li><a href="https://github.com/bannedbook/fanqiang" target="_blank" rel="noreferrer">https://github.com/bannedbook/fanqiang</a>（<a href="https://fanqiang.gitbook.io/fanqiang" target="_blank" rel="noreferrer">GitBook 分站</a>）</li><li><a href="https://github.com/Alvin9999-newpac/fanqiang" target="_blank" rel="noreferrer">https://github.com/Alvin9999-newpac/fanqiang</a></li></ul><h2 id="客户端导航" tabindex="-1">客户端导航 <a class="header-anchor" href="#客户端导航" aria-label="Permalink to &quot;客户端导航&quot;">​</a></h2><ul><li>虚空终端：<a href="https://wiki.metacubex.one/" target="_blank" rel="noreferrer">https://wiki.metacubex.one/</a></li><li><a href="https://kejifenxiang.com/" target="_blank" rel="noreferrer">科技分享</a>：<a href="https://kejifenxiang.com/tools" target="_blank" rel="noreferrer">https://kejifenxiang.com/tools</a></li><li><a href="https://subconverter.org/clients/" target="_blank" rel="noreferrer">SubConverter</a>：<a href="https://subconverter.org/clients/" target="_blank" rel="noreferrer">https://subconverter.org/clients/</a></li><li><a href="https://v2rayssr.com/" target="_blank" rel="noreferrer">V2RaySSR 综合网</a>：<a href="https://v2rayssr.com/vpn-client.html" target="_blank" rel="noreferrer">https://v2rayssr.com/vpn-client.html</a></li><li>全平台翻墙工具：<a href="https://binghe.gitbook.io/quan-ping-tai-fan-qiang-gong-ju/" target="_blank" rel="noreferrer">https://binghe.gitbook.io/quan-ping-tai-fan-qiang-gong-ju/</a></li><li><a href="https://jichangtuijian.com/" target="_blank" rel="noreferrer">机场推荐</a>：<a href="https://jichangtuijian.com/proxyclient.html" target="_blank" rel="noreferrer">https://jichangtuijian.com/proxyclient.html</a></li><li><a href="https://findladders.com/" target="_blank" rel="noreferrer">找梯子啊</a>：<a href="https://findladders.com/clients/" target="_blank" rel="noreferrer">https://findladders.com/clients/</a></li></ul><h2 id="android-系统架构区别" tabindex="-1">Android 系统架构区别 <a class="header-anchor" href="#android-系统架构区别" aria-label="Permalink to &quot;Android 系统架构区别&quot;">​</a></h2><ul><li><code>armv8 (ARMv8)</code>、<code>arm64-v8a (ARM64-v8a)</code>、<code>aarch64</code>：ARM 64位架构，适用于目前所有主流设备；</li><li><code>armv7 (ARMv7)</code>、<code>arm32-v7a (ARM32-v7a)</code>、<code>armeabi-v7a</code>：ARM 32位架构，适用于较旧的设备；</li><li><code>x86</code>、<code>x86_64</code>： Intel/AMD 架构，多用于模拟器，极少数设备搭载该架构。<code>x86</code> 为 32 位，<code>x86_64</code> 为 64 位。</li></ul><h2 id="windows-架构详细说明" tabindex="-1">Windows 架构详细说明 <a class="header-anchor" href="#windows-架构详细说明" aria-label="Permalink to &quot;Windows 架构详细说明&quot;">​</a></h2><details class="custom-block details"><summary>字太多就不展开了，自己点开看看吧……</summary><div class="details-content"><div class="details-inner"><p>既然你要求“列出所有内容并详细介绍”，那么我们将不仅仅局限于目前的 Intel vs. ARM 对比，而是从计算机工程和 Windows 历史发展的角度，深入剖析 Windows 曾经支持过、正在支持以及通过特殊技术兼容的所有架构体系。</p><p>Windows 操作系统（特别是 Windows NT 内核）在设计之初就具备高度的“可移植性”（Portability），通过硬件抽象层（HAL）隔离底层差异。因此，Windows 历史上运行过的架构非常多。</p><p>以下是 Windows 电脑架构的<strong>完整全景图</strong>：</p><hr><h3>第一部分：现代主流架构 (Current Mainstream)</h3><p>这是你现在去商店能买到的电脑所使用的架构。</p><h4>1. x86 (32-bit) / IA-32</h4> * **全称：** Intel Architecture 32-bit * **状态：** **逐渐淘汰**（Windows 11 已不再发布 32 位版本，但 Windows 10 及更早版本仍支持）。 * **技术细节：** * 基于 Intel 80386 确立的标准。 * **寄存器：** 32位通用寄存器（EAX, EBX, ECX 等）。 * **内存寻址：** 理论最大寻址空间为 4GB ($2^{32}$)。虽然通过 PAE (物理地址扩展) 技术可以支持更多物理内存，但单个进程只能使用 2GB 或 3GB 用户空间。 * **指令集特点：** CISC（复杂指令集）。指令长度可变。 * **适用场景：** 老旧的工业电脑、ATM 机、早期上网本。 <h4>2. x86-64 / x64 / AMD64</h4> * **全称：** x86-64 (AMD64 / Intel 64) * **状态：** **绝对霸主**（目前的行业标准）。 * **历史冷知识：** 这个架构是 **AMD** 发明的（所以叫 AMD64），后来 Intel 被迫跟进并授权使用（称为 Intel 64）。 * **技术细节：** * 是 x86 的 64 位扩展，向后兼容 32 位 x86 代码。 * **寄存器：** 64位通用寄存器（RAX, RBX...）以及增加了 R8-R15 等新寄存器。 * **内存寻址：** 理论支持 16 EB（Exabytes）内存，目前的 Windows 专业版通常限制在 2TB - 6TB 左右，彻底解决了内存瓶颈。 * **安全特性：** 引入了 NX Bit (No-Execute) 防止缓冲区溢出攻击。 * **适用场景：** 95% 以上的家用电脑、游戏本、工作站、服务器。 <h4>3. ARM64 / AArch64 (Windows on ARM)</h4> * **全称：** ARM Architecture 64-bit * **状态：** **快速上升期**（微软和高通重点发力的未来方向）。 * **技术细节：** * 基于 **RISC**（精简指令集）。指令长度通常固定，译码效率高。 * **SoC 设计：** 也就是 System on Chip。CPU、GPU、NPU（神经处理单元）、基带通常封装在一起，内存通常直接焊死在主板或封装在芯片旁（Unified Memory），以此降低延迟。 * **大小核架构 (big.LITTLE)：** 拥有高性能核心（Performance Cores）和高能效核心（Efficiency Cores），这也是其续航极长的物理基础。 * **适用场景：** Copilot+ PC、Surface Pro X/11、主打 AI 和长续航的轻薄本。 <hr><h3>第二部分：中间层与兼容架构 (Emulation &amp; Compatibility)</h3><p>Windows 最强大的地方在于：即便硬件架构变了，它也能通过软件让旧程序跑起来。这些是“虚拟”的架构层。</p><h4>1. WOW64 (Windows on Windows 64)</h4> * **功能：** 让 **32位 x86 软件** 运行在 **64位 x64 系统** 上。 * **原理：** 当你在 64 位 Windows 上运行一个老游戏（如《红警2》）时，系统会加载 `wow64.dll` 等库，将 32 位的系统调用（System Calls）“翻译”成 64 位调用传给内核。 * **重要性：** 没有它，你的新电脑就玩不了旧游戏，用不了旧软件。 <h4>2. ARM 上的 x86/x64 模拟器 (Prism / CHPE)</h4> * **功能：** 让 **传统 Intel/AMD 软件** 运行在 **ARM 芯片** 上。 * **Windows 10 ARM：** 只能模拟 32位 x86 软件。 * **Windows 11 ARM：** 引入了 **ARM64EC** (Emulation Compatible) 和 **Prism** 转译技术，支持模拟 64位 x64 软件。 * **原理：** 类似于苹果的 Rosetta 2，它包含即时编译（JIT）和缓存机制，将 x86 指令块翻译成 ARM64 指令块。 * **限制：** 不能模拟内核驱动程序（AVX 指令集支持也有限）。 <h4>4. MSIL / CIL (.NET 架构)</h4> * **概念：** 也就是 C# 或 VB.NET 编译出的 `.exe`。 * **Any CPU：** 这类程序不直接包含机器码，而是包含“中间语言”。当你运行它时，CLR (公共语言运行时) 会根据你当前的 CPU（无论是 x64 还是 ARM64）**即时编译**成原生代码。 * **优势：** 这是真正的“一次编写，到处运行”。 <hr><h3>第三部分：已消亡的历史架构 (The Graveyard of Windows NT)</h3><p>Windows NT 内核设计之初是为了支持 RISC 工作站的。以下是 Windows 曾经正式支持，但因市场原因被砍掉的架构。</p><h4 id="_1-ia-64-itanium-安腾" tabindex="-1">1. IA-64 (Itanium / 安腾) <a class="header-anchor" href="#_1-ia-64-itanium-安腾" aria-label="Permalink to &quot;1. IA-64 (Itanium / 安腾)&quot;">​</a></h4><ul><li><strong>厂商：</strong> Intel &amp; HP</li><li><strong>特点：</strong> <strong>EPIC</strong> (显式并行指令运算)。Intel 曾以此豪赌未来，认为它会取代 x86。它不兼容 x86（除非通过极慢的模拟）。</li><li><strong>支持版本：</strong> Windows XP 64-bit Edition (Version 2002/2003), Windows Server 2003/2008 for Itanium.</li><li><strong>结局：</strong> 彻底失败。因为 AMD 推出的 x86-64 (x64) 完美兼容旧软件，性能也不差，安腾被市场抛弃。</li></ul><h4 id="_2-dec-alpha" tabindex="-1">2. DEC Alpha <a class="header-anchor" href="#_2-dec-alpha" aria-label="Permalink to &quot;2. DEC Alpha&quot;">​</a></h4><ul><li><strong>厂商：</strong> Digital Equipment Corp (DEC)</li><li><strong>特点：</strong> 90年代地球上<strong>速度最快</strong>的处理器，纯 64 位设计（但在 Windows 上运行在 32 位模式）。</li><li><strong>支持版本：</strong> Windows NT 3.1 到 Windows NT 4.0，甚至 Windows 2000 的早期 Beta 版。</li><li><strong>结局：</strong> 康柏（Compaq）收购 DEC 后终止了该项目，Windows 停止支持。</li></ul><h4 id="_3-mips-r4000-等" tabindex="-1">3. MIPS (R4000 等) <a class="header-anchor" href="#_3-mips-r4000-等" aria-label="Permalink to &quot;3. MIPS (R4000 等)&quot;">​</a></h4><ul><li><strong>厂商：</strong> MIPS Technologies</li><li><strong>特点：</strong> 精简指令集的代表。事实上，<strong>Windows NT 的第一行代码是在 MIPS 电脑上写出来的</strong>，而不是 Intel 电脑。</li><li><strong>支持版本：</strong> Windows NT 3.1 到 NT 4.0。</li><li><strong>结局：</strong> 微软为了减少维护成本，在 Windows 2000 发布前放弃了支持。</li></ul><h4 id="_4-powerpc" tabindex="-1">4. PowerPC <a class="header-anchor" href="#_4-powerpc" aria-label="Permalink to &quot;4. PowerPC&quot;">​</a></h4><ul><li><strong>厂商：</strong> IBM / Motorola</li><li><strong>特点：</strong> 也就是当年苹果 Mac 使用的架构。IBM 和微软曾合作推出基于 PowerPC 的 ThinkPad（运行 Windows NT）。</li><li><strong>支持版本：</strong> Windows NT 3.51 和 NT 4.0。</li><li><strong>结局：</strong> 市场占有率太低，被砍掉。</li></ul><h4 id="_5-windows-rt-arm32" tabindex="-1">5. Windows RT (ARM32) <a class="header-anchor" href="#_5-windows-rt-arm32" aria-label="Permalink to &quot;5. Windows RT (ARM32)&quot;">​</a></h4><ul><li><strong>厂商：</strong> Nvidia (Tegra), Qualcomm</li><li><strong>特点：</strong> 微软在 2012 年发布的 Surface RT 使用的架构。这是微软首次尝试 ARM。</li><li><strong>致命伤：</strong> 虽然内核是 Windows，但微软<strong>人为锁死</strong>了系统，禁止运行任何传统的桌面软件（exe），只能装应用商店的 App。它和现在的 &quot;Windows on ARM&quot; 是两回事。</li><li><strong>结局：</strong> 惨败，被废弃。</li></ul><hr><h3 id="第四部分-深度技术参数对比表" tabindex="-1">第四部分：深度技术参数对比表 <a class="header-anchor" href="#第四部分-深度技术参数对比表" aria-label="Permalink to &quot;第四部分：深度技术参数对比表&quot;">​</a></h3><p>为了满足你“详细介绍”的需求，以下是从操作系统内核开发角度的对比：</p><table tabindex="0"><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">x86 (Legacy)</th><th style="text-align:left;">x64 (Mainstream)</th><th style="text-align:left;">ARM64 (Modern)</th><th style="text-align:left;">IA-64 (Itanium) - 已死</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>指令集类型</strong></td><td style="text-align:left;">CISC (变长指令)</td><td style="text-align:left;">CISC (变长指令)</td><td style="text-align:left;">RISC (定长指令 4字节)</td><td style="text-align:left;">EPIC (显式并行)</td></tr><tr><td style="text-align:left;"><strong>字节序 (Endianness)</strong></td><td style="text-align:left;">Little-Endian</td><td style="text-align:left;">Little-Endian</td><td style="text-align:left;">Bi-Endian (Windows 强制使用 Little-Endian)</td><td style="text-align:left;">Little-Endian</td></tr><tr><td style="text-align:left;"><strong>内存页大小 (Page)</strong></td><td style="text-align:left;">4KB (支持 4MB 大页)</td><td style="text-align:left;">4KB (支持 2MB/1GB 大页)</td><td style="text-align:left;">4KB (支持 64KB 等多级)</td><td style="text-align:left;">8KB / 16KB 等</td></tr><tr><td style="text-align:left;"><strong>函数调用约定</strong></td><td style="text-align:left;">cdecl, stdcall (依赖堆栈)</td><td style="text-align:left;"><strong>FastCall</strong> (前4个参数用寄存器 RCX/RDX/R8/R9)</td><td style="text-align:left;"><strong>AAPCS64</strong> (前8个参数用寄存器 X0-X7)</td><td style="text-align:left;">-</td></tr><tr><td style="text-align:left;"><strong>内核态/用户态切换</strong></td><td style="text-align:left;">较慢 (Ring 0 - Ring 3)</td><td style="text-align:left;">优化过 (Syscall 指令)</td><td style="text-align:left;">极快 (Exception levels EL0/EL1)</td><td style="text-align:left;">-</td></tr><tr><td style="text-align:left;"><strong>驱动程序要求</strong></td><td style="text-align:left;"><code>.sys</code> (32位 x86)</td><td style="text-align:left;"><code>.sys</code> (64位 x64, 必须有数字签名)</td><td style="text-align:left;"><code>.sys</code> (ARM64 专用, 必须签名)</td><td style="text-align:left;"><code>.sys</code> (IA-64 专用)</td></tr><tr><td style="text-align:left;"><strong>硬件强制兼容性</strong></td><td style="text-align:left;">极高</td><td style="text-align:left;">极高</td><td style="text-align:left;">较低 (依赖 ACPI 表描述硬件)</td><td style="text-align:left;">-</td></tr></tbody></table><h3 id="总结-我该怎么看" tabindex="-1">总结：我该怎么看？ <a class="header-anchor" href="#总结-我该怎么看" aria-label="Permalink to &quot;总结：我该怎么看？&quot;">​</a></h3><ol><li><strong>如果你是普通用户/玩家：</strong> 你只需要关心 <strong>x64</strong>。这是你目前使用的，也是兼容性最好的。</li><li><strong>如果你追求极致移动体验：</strong> 关注 <strong>ARM64</strong> (Snapdragon X Elite)，这是 Windows 的未来变数，类似于 MacBook 的 M 系列芯片体验。</li><li><strong>如果你是考古爱好者：</strong> 可以去研究 DEC Alpha 或 Itanium 版本的 Windows，那是 Windows NT 架构“纯洁性”的证明——证明了 Windows 不仅仅是 Intel 的附属品。</li></ol></div></div></details><h2 id="↓在这里选择客户端" tabindex="-1">↓在这里选择客户端~ <a class="header-anchor" href="#↓在这里选择客户端" aria-label="Permalink to &quot;↓在这里选择客户端~&quot;">​</a></h2>',11)),o(e)])}const m=a(s,[["render",d]]);export{u as __pageData,m as default};
