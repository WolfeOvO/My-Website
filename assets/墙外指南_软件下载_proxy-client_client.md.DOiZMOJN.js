import{_ as n,C as l,o as i,c as o,aj as r,E as s}from"./chunks/framework.C0O9U8MM.js";const u=JSON.parse('{"title":"客户端（代理软件）","description":"","frontmatter":{},"headers":[],"relativePath":"墙外指南/软件下载/proxy-client/client.md","filePath":"墙外指南/软件下载/proxy-client/client.md","lastUpdated":1769255272000}'),a={name:"墙外指南/软件下载/proxy-client/client.md"};function d(g,t,c,h,p,f){const e=l("sidebar");return i(),o("div",null,[t[0]||(t[0]=r('<h1 id="客户端-代理软件" tabindex="-1">客户端（代理软件） <a class="header-anchor" href="#客户端-代理软件" aria-label="Permalink to &quot;客户端（代理软件）&quot;">​</a></h1><div class="custom-block info"><p class="custom-block-title">提示</p><p>若下载速度过慢或无法下载，请阅读<a href="/墙外指南/教程/加速GitHub下载.html">《加速 GitHub 下载》</a>一文。</p></div><h2 id="免客户端翻墙" tabindex="-1">免客户端翻墙 <a class="header-anchor" href="#免客户端翻墙" aria-label="Permalink to &quot;免客户端翻墙&quot;">​</a></h2><ul><li><a href="https://github.com/bannedbook/fanqiang" target="_blank" rel="noreferrer">https://github.com/bannedbook/fanqiang</a>（<a href="https://fanqiang.gitbook.io/fanqiang" target="_blank" rel="noreferrer">GitBook 分站</a>）</li><li><a href="https://github.com/Alvin9999-newpac/fanqiang" target="_blank" rel="noreferrer">https://github.com/Alvin9999-newpac/fanqiang</a></li></ul><h2 id="客户端导航" tabindex="-1">客户端导航 <a class="header-anchor" href="#客户端导航" aria-label="Permalink to &quot;客户端导航&quot;">​</a></h2><ul><li>虚空终端：<a href="https://wiki.metacubex.one/" target="_blank" rel="noreferrer">https://wiki.metacubex.one/</a></li><li><a href="https://kejifenxiang.com/" target="_blank" rel="noreferrer">科技分享</a>：<a href="https://kejifenxiang.com/tools" target="_blank" rel="noreferrer">https://kejifenxiang.com/tools</a></li><li><a href="https://subconverter.org/clients/" target="_blank" rel="noreferrer">SubConverter</a>：<a href="https://subconverter.org/clients/" target="_blank" rel="noreferrer">https://subconverter.org/clients/</a></li><li><a href="https://v2rayssr.com/" target="_blank" rel="noreferrer">V2RaySSR 综合网</a>：<a href="https://v2rayssr.com/vpn-client.html" target="_blank" rel="noreferrer">https://v2rayssr.com/vpn-client.html</a></li><li>全平台翻墙工具：<a href="https://binghe.gitbook.io/quan-ping-tai-fan-qiang-gong-ju/" target="_blank" rel="noreferrer">https://binghe.gitbook.io/quan-ping-tai-fan-qiang-gong-ju/</a></li><li><a href="https://jichangtuijian.com/" target="_blank" rel="noreferrer">机场推荐</a>：<a href="https://jichangtuijian.com/proxyclient.html" target="_blank" rel="noreferrer">https://jichangtuijian.com/proxyclient.html</a></li><li><a href="https://findladders.com/" target="_blank" rel="noreferrer">找梯子啊</a>：<a href="https://findladders.com/clients/" target="_blank" rel="noreferrer">https://findladders.com/clients/</a></li></ul><h2 id="android-系统架构区别" tabindex="-1">Android 系统架构区别 <a class="header-anchor" href="#android-系统架构区别" aria-label="Permalink to &quot;Android 系统架构区别&quot;">​</a></h2><ul><li><code>armv8 (ARMv8)</code>、<code>arm64-v8a (ARM64-v8a)</code>、<code>aarch64</code>：ARM 64位架构，适用于目前所有主流设备；</li><li><code>armv7 (ARMv7)</code>、<code>arm32-v7a (ARM32-v7a)</code>、<code>armeabi-v7a</code>：ARM 32位架构，适用于较旧的设备；</li><li><code>x86</code>、<code>x86_64</code>：Intel/AMD 架构，多用于模拟器，极少数设备搭载该架构。<code>x86</code> 为 32 位，<code>x86_64</code> 为 64 位。</li></ul><h2 id="windows-架构详细说明" tabindex="-1">Windows 架构详细说明 <a class="header-anchor" href="#windows-架构详细说明" aria-label="Permalink to &quot;Windows 架构详细说明&quot;">​</a></h2><div class="vp-doc"><div class="license-block ai-declaration" data-type="generated" data-media="text"><div class="license-header"><div class="license-icon ai-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="10" x="3" y="11" rx="2"></rect><circle cx="12" cy="5" r="2"></circle><path d="M12 7v4"></path><line x1="8" x2="8" y1="16" y2="16"></line><line x1="16" x2="16" y1="16" y2="16"></line></svg></div><div class="license-info"><div class="license-title"><span class="ai-type-badge"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"></path><path d="M5 3v4"></path><path d="M19 17v4"></path><path d="M3 5h4"></path><path d="M17 19h4"></path></svg><span>AI 生成</span></span><span class="ai-model-badge">Gemini<small>Google</small></span></div><div class="license-subtitle"><span class="media-type"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 6.1H3"></path><path d="M21 12.1H3"></path><path d="M15.1 18H3"></path></svg><span>文本</span></span><span class="separator">·</span><span>此文本由人工智能模型生成，可能部分或完全未经人类实质性修改。</span></div></div></div><div class="license-body"></div><div class="license-text">请注意进行多方查证甄别真实性。</div></div></div><details class="custom-block details"><summary>字太多就不展开了，自己点开看看吧……</summary><div class="details-content"><div class="details-inner"><p>既然你要求「列出所有内容并详细介绍」，那么我们将不仅仅局限于目前的 Intel vs. ARM 对比，而是从计算机工程和 Windows 历史发展的角度，深入剖析 Windows 曾经支持过、正在支持以及通过特殊技术兼容的所有架构体系。</p><p>Windows 操作系统（特别是 Windows NT 内核）在设计之初就具备高度的「可移植性」（Portability），通过硬件抽象层（HAL）隔离底层差异。因此，Windows 历史上运行过的架构非常多。</p><p>以下是 Windows 电脑架构的<strong>完整全景图</strong>：</p><hr><h3>第一部分：现代主流架构 (Current Mainstream)</h3><p>这是你现在去商店能买到的电脑所使用的架构：</p><h4>1. x86 (32-bit) / IA-32</h4><ul><li><strong>全称</strong>：Intel Architecture 32-bit</li><li><strong>状态</strong>：<strong>逐渐淘汰</strong>（Windows 11 已不再发布 32 位版本，但 Windows 10 及更早版本仍支持）。</li><li><strong>技术细节</strong>： <ul><li>基于 Intel 80386 确立的标准。</li><li><strong>寄存器</strong>：32位通用寄存器（EAX, EBX, ECX 等）。</li><li><strong>内存寻址</strong>：理论最大寻址空间为 4GB ($2^{32}$)。虽然通过 PAE (物理地址扩展) 技术可以支持更多物理内存，但单个进程只能使用 2GB 或 3GB 用户空间。</li><li><strong>指令集特点</strong>：CISC（复杂指令集）。指令长度可变。</li><li><strong>适用场景</strong>：老旧的工业电脑、ATM 机、早期上网本。</li></ul></li></ul><h4>2. x86-64 / x64 / AMD64</h4><ul><li><strong>全称</strong>：x86-64 (AMD64 / Intel 64)</li><li><strong>状态</strong>：<strong>绝对霸主</strong>（目前的行业标准）。</li><li><strong>历史冷知识</strong>：这个架构是 <strong>AMD</strong> 发明的（所以叫 AMD64），后来 Intel 被迫跟进并授权使用（称为 Intel 64）。</li><li><strong>技术细节</strong>： <ul><li>是 x86 的 64 位扩展，向后兼容 32 位 x86 代码。</li><li><strong>寄存器</strong>：64 位通用寄存器（RAX, RBX...）以及增加了 R8-R15 等新寄存器。</li><li><strong>内存寻址</strong>：理论支持 16 EB（Exabytes）内存，目前的 Windows 专业版通常限制在 2TB - 6TB 左右，彻底解决了内存瓶颈。</li><li><strong>安全特性</strong>：引入了 NX Bit (No-Execute) 防止缓冲区溢出攻击。</li></ul></li><li><strong>适用场景</strong>：95% 以上的家用电脑、游戏本、工作站、服务器。</li></ul><h4>3. ARM64 / AArch64 (Windows on ARM)</h4><ul><li><strong>全称</strong>：ARM Architecture 64-bit</li><li><strong>状态</strong>：<strong>快速上升期</strong>（微软和高通重点发力的未来方向）。</li><li><strong>技术细节</strong>： <ul><li>基于 <strong>RISC</strong>（精简指令集）。指令长度通常固定，译码效率高。</li><li><strong>SoC 设计</strong>：也就是 System on Chip。CPU、GPU、NPU（神经处理单元）、基带通常封装在一起，内存通常直接焊死在主板或封装在芯片旁（Unified Memory），以此降低延迟。</li><li><strong>大小核架构 (big.LITTLE)</strong>：拥有高性能核心（Performance Cores）和高能效核心（Efficiency Cores），这也是其续航极长的物理基础。</li></ul></li><li><strong>适用场景</strong>：Copilot+ PC、Surface Pro X/11、主打 AI 和长续航的轻薄本。</li></ul><hr><h3>第二部分：中间层与兼容架构 (Emulation &amp; Compatibility)</h3><p>Windows 最强大的地方在于：即便硬件架构变了，它也能通过软件让旧程序跑起来。这些是「虚拟」的架构层。</p><h4>1. WOW64 (Windows on Windows 64)</h4><ul><li><strong>功能</strong>：让 <strong>32位 x86 软件</strong> 运行在 <strong>64位 x64 系统</strong> 上。</li><li><strong>原理</strong>：当你在 64 位 Windows 上运行一个老游戏（如《红警2》）时，系统会加载 <code>wow64.dll</code> 等库，将 32 位的系统调用（System Calls）「翻译」成 64 位调用传给内核。</li><li><strong>重要性</strong>：没有它，你的新电脑就玩不了旧游戏，用不了旧软件。</li></ul><h4>2. ARM 上的 x86/x64 模拟器 (Prism / CHPE)</h4><ul><li><strong>功能</strong>：让 <strong>传统 Intel/AMD 软件</strong> 运行在 <strong>ARM 芯片</strong> 上。</li><li><strong>Windows 10 ARM</strong>：只能模拟 32位 x86 软件。</li><li><strong>Windows 11 ARM</strong>：引入了 <strong>ARM64EC</strong> (Emulation Compatible) 和 <strong>Prism</strong> 转译技术，支持模拟 64位 x64 软件。</li><li><strong>原理</strong>：类似于苹果的 Rosetta 2，它包含即时编译（JIT）和缓存机制，将 x86 指令块翻译成 ARM64 指令块。</li><li><strong>限制</strong>：不能模拟内核驱动程序（AVX 指令集支持也有限）。</li></ul><h4>4. MSIL / CIL (.NET 架构)</h4><ul><li><strong>概念</strong>：也就是 C# 或 VB.NET 编译出的 <code>.exe</code>。</li><li><strong>Any CPU</strong>：这类程序不直接包含机器码，而是包含「中间语言」。当你运行它时，CLR (公共语言运行时) 会根据你当前的 CPU（无论是 x64 还是 ARM64）<strong>即时编译</strong>成原生代码。</li><li><strong>优势</strong>：这是真正的「一次编写，到处运行」。</li></ul><hr><h3>第三部分：已消亡的历史架构 (The Graveyard of Windows NT)</h3><p>Windows NT 内核设计之初是为了支持 RISC 工作站的。以下是 Windows 曾经正式支持，但因市场原因被砍掉的架构。</p><h4>1. IA-64 (Itanium / 安腾)</h4><ul><li><strong>厂商</strong>：Intel &amp; HP</li><li><strong>特点</strong>：<strong>EPIC</strong> (显式并行指令运算)。Intel 曾以此豪赌未来，认为它会取代 x86。它不兼容 x86（除非通过极慢的模拟）。</li><li><strong>支持版本</strong>：Windows XP 64-bit Edition (Version 2002/2003), Windows Server 2003/2008 for Itanium.</li><li><strong>结局</strong>：彻底失败。因为 AMD 推出的 x86-64 (x64) 完美兼容旧软件，性能也不差，安腾被市场抛弃。</li></ul><h4>2. DEC Alpha</h4><ul><li><strong>厂商</strong>：Digital Equipment Corp (DEC)</li><li><strong>特点</strong>：90年代地球上<strong>速度最快</strong>的处理器，纯 64 位设计（但在 Windows 上运行在 32 位模式）。</li><li><strong>支持版本</strong>：Windows NT 3.1 到 Windows NT 4.0，甚至 Windows 2000 的早期 Beta 版。</li><li><strong>结局</strong>：康柏（Compaq）收购 DEC 后终止了该项目，Windows 停止支持。</li></ul><h4>3. MIPS (R4000 等)</h4><ul><li><strong>厂商</strong>：MIPS Technologies</li><li><strong>特点</strong>：精简指令集的代表。事实上，<strong>Windows NT 的第一行代码是在 MIPS 电脑上写出来的</strong>，而不是 Intel 电脑。</li><li><strong>支持版本</strong>：Windows NT 3.1 到 NT 4.0。</li><li><strong>结局</strong>：微软为了减少维护成本，在 Windows 2000 发布前放弃了支持。</li></ul><h4>4. PowerPC</h4><ul><li><strong>厂商</strong>：IBM / Motorola</li><li><strong>特点</strong>：也就是当年苹果 Mac 使用的架构。IBM 和微软曾合作推出基于 PowerPC 的 ThinkPad（运行 Windows NT）。</li><li><strong>支持版本</strong>：Windows NT 3.51 和 NT 4.0。</li><li><strong>结局</strong>：市场占有率太低，被砍掉。</li></ul><h4>5. Windows RT (ARM32)</h4><ul><li><strong>厂商</strong>：Nvidia (Tegra), Qualcomm</li><li><strong>特点</strong>：微软在 2012 年发布的 Surface RT 使用的架构。这是微软首次尝试 ARM。</li><li><strong>致命伤</strong>：虽然内核是 Windows，但微软<strong>人为锁死</strong>了系统，禁止运行任何传统的桌面软件（exe），只能装应用商店的 App。它和现在的 &quot;Windows on ARM&quot; 是两回事。</li><li><strong>结局</strong>：惨败，被废弃。</li></ul><hr><h3>第四部分：深度技术参数对比表</h3><p>以下是从操作系统内核开发角度的对比：</p><table tabindex="0"><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">x86 (Legacy)</th><th style="text-align:left;">x64 (Mainstream)</th><th style="text-align:left;">ARM64 (Modern)</th><th style="text-align:left;">IA-64 (Itanium) - 已死</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>指令集类型</strong></td><td style="text-align:left;">CISC (变长指令)</td><td style="text-align:left;">CISC (变长指令)</td><td style="text-align:left;">RISC (定长指令 4字节)</td><td style="text-align:left;">EPIC (显式并行)</td></tr><tr><td style="text-align:left;"><strong>字节序 (Endianness)</strong></td><td style="text-align:left;">Little-Endian</td><td style="text-align:left;">Little-Endian</td><td style="text-align:left;">Bi-Endian (Windows 强制使用 Little-Endian)</td><td style="text-align:left;">Little-Endian</td></tr><tr><td style="text-align:left;"><strong>内存页大小 (Page)</strong></td><td style="text-align:left;">4KB (支持 4MB 大页)</td><td style="text-align:left;">4KB (支持 2MB/1GB 大页)</td><td style="text-align:left;">4KB (支持 64KB 等多级)</td><td style="text-align:left;">8KB / 16KB 等</td></tr><tr><td style="text-align:left;"><strong>函数调用约定</strong></td><td style="text-align:left;">cdecl, stdcall (依赖堆栈)</td><td style="text-align:left;"><strong>FastCall</strong> (前4个参数用寄存器 RCX/RDX/R8/R9)</td><td style="text-align:left;"><strong>AAPCS64</strong> (前8个参数用寄存器 X0-X7)</td><td style="text-align:left;">-</td></tr><tr><td style="text-align:left;"><strong>内核态/用户态切换</strong></td><td style="text-align:left;">较慢 (Ring 0 - Ring 3)</td><td style="text-align:left;">优化过 (Syscall 指令)</td><td style="text-align:left;">极快 (Exception levels EL0/EL1)</td><td style="text-align:left;">-</td></tr><tr><td style="text-align:left;"><strong>驱动程序要求</strong></td><td style="text-align:left;"><code>.sys</code> (32位 x86)</td><td style="text-align:left;"><code>.sys</code> (64位 x64, 必须有数字签名)</td><td style="text-align:left;"><code>.sys</code> (ARM64 专用, 必须签名)</td><td style="text-align:left;"><code>.sys</code> (IA-64 专用)</td></tr><tr><td style="text-align:left;"><strong>硬件强制兼容性</strong></td><td style="text-align:left;">极高</td><td style="text-align:left;">极高</td><td style="text-align:left;">较低 (依赖 ACPI 表描述硬件)</td><td style="text-align:left;">-</td></tr></tbody></table><h3>总结：我该怎么看？</h3><ol><li><strong>如果你是普通用户/玩家</strong>：你只需要关心 <strong>x64</strong>。这是你目前使用的，也是兼容性最好的。</li><li><strong>如果你追求极致移动体验</strong>：关注 <strong>ARM64</strong> (Snapdragon X Elite)，这是 Windows 的未来变数，类似于 MacBook 的 M 系列芯片体验。</li><li><strong>如果你是考古爱好者</strong>：可以去研究 DEC Alpha 或 Itanium 版本的 Windows，那是 Windows NT 架构「纯洁性」的证明——证明了 Windows 不仅仅是 Intel 的附属品。</li></ol></div></div></details><h2 id="↓在这里选择客户端" tabindex="-1">↓在这里选择客户端~ <a class="header-anchor" href="#↓在这里选择客户端" aria-label="Permalink to &quot;↓在这里选择客户端~&quot;">​</a></h2>',12)),s(e)])}const m=n(a,[["render",d]]);export{u as __pageData,m as default};
